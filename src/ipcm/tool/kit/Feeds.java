package ipcm.tool.kit;

import android.content.Context;
import android.os.AsyncTask;
import android.util.Log;
import android.widget.ArrayAdapter;
import android.widget.Toast;
import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;
import org.xmlpull.v1.XmlPullParserFactory;
import twitter4j.*;

import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;

public class Feeds {

    public static Context context;
    static DataHelper db;

    public Feeds(Context context){
        this.context = context;
        db = new DataHelper(this.context);
    }

    // NEWS FEEDS

    // Just executes a thread
    public static void testNewsFeed(String feed){

        new TestNewsFeedTask().execute(feed);

    }

    // Takes a given URL and ensure that we can parse it into a NewsFeed
    private static class TestNewsFeedTask extends AsyncTask<String, Void, Boolean>{

        XmlPullParser xpp;
        URL url;
        boolean caughtException = false;

        @Override
        protected void onPreExecute(){ /* Nothing to do */ }

        @Override
        protected Boolean doInBackground(String... urls){

            try{
                String s = urls[0];
                // Ensure that the url starts with "http://"
                if(!s.substring(0, 7).equals("http://")){
                    s = "http://" + s;
                }

                url = new URL(s);
                XmlPullParserFactory factory = XmlPullParserFactory.newInstance();
                factory.setNamespaceAware(false);
                xpp = factory.newPullParser();

                if(xpp != null && url != null)
                    xpp.setInput(getInputStream(url), "UTF_8");

            }catch(MalformedURLException e){
                e.printStackTrace();
                caughtException = true;
            }catch(XmlPullParserException e){
                e.printStackTrace();
                caughtException = true;
            }catch(IndexOutOfBoundsException e){
                e.printStackTrace();
                caughtException = true;
            }catch(IllegalArgumentException e){
                e.printStackTrace();
                caughtException = true;
            }

            if(caughtException){
                return false;
            }

            // At this point, we know that it is a valid URL, but not necessarily that it is a parsable feed, so we need
            // to make sure that we can parse it and create CropManagerArticles out of it.

            // Cast it to a WPRSS feed
            NewsFeed testFeed = new NewsFeed(url.toString(), NewsFeed.WP_RSS);
            caughtException = attemptNewsFeedParse(testFeed);

            // Declare whether or not we caught an exception
            return caughtException;

        }

        @Override
        protected void onPostExecute(Boolean b){
            if(!b){
                // Notify the user that we were unable to parse the feed
                Toast toast = Toast.makeText(context, "Unable to read feed", Toast.LENGTH_SHORT);
                toast.show();
                caughtException = false;
            }else{
                // Add feed to database
                Feeds.db.insertNewsFeed(url.toString(), NewsFeed.WP_RSS);

                // Notify the user that we were successful
                Toast toast = Toast.makeText(context, "Feed added", Toast.LENGTH_SHORT);
                toast.show();
                caughtException = false;
            }
        }

    }

    public static ArrayList<CropManagerArticle> parseNewsFeed(NewsFeed feed){

        // A standard RSS feed generated by Wordpress (Key: wp_rss)
        if(feed.feedType.equals(NewsFeed.WP_RSS)){
            ArrayList<CropManagerArticle> articlesTemp = new ArrayList<CropManagerArticle>();
            ArrayList<String> titles = new ArrayList<String>();
            ArrayList<String> dates = new ArrayList<String>();
            ArrayList<String> links = new ArrayList<String>();

            try{


                URL url = new URL(feed.url);

                XmlPullParserFactory factory = XmlPullParserFactory.newInstance();
                factory.setNamespaceAware(false);
                XmlPullParser xpp = factory.newPullParser();

                xpp.setInput(getInputStream(url), "UTF_8");

                boolean insideItem = false;
                int eventType = xpp.getEventType();

                while(eventType != XmlPullParser.END_DOCUMENT){
                    if(eventType == XmlPullParser.START_TAG){
                        if(xpp.getName().equalsIgnoreCase("item")){
                            insideItem = true;
                        } else if(xpp.getName().equalsIgnoreCase("title")){
                            if(insideItem)
                                titles.add(xpp.nextText());
                        } else if(xpp.getName().equalsIgnoreCase("pubdate")){
                            if(insideItem)
                                dates.add(xpp.nextText());
                        } else if(xpp.getName().equalsIgnoreCase("link")){
                            if(insideItem)
                                links.add(xpp.nextText());
                        }

                    } else if(eventType == XmlPullParser.END_TAG &&
                            xpp.getName().equalsIgnoreCase("item")){
                        insideItem = false;
                    }

                    eventType = xpp.next();
                }

                int min = min(titles.size(), links.size());
                for(int i = 0; i < min; i++)
                {
                    if(dates.size() > 0)
                        articlesTemp.add(new CropManagerArticle(titles.get(i), parseDate(dates.get(i)), links.get(i)));
                    else
                        articlesTemp.add(new CropManagerArticle(titles.get(i), null, links.get(i)));

                }

            }catch(MalformedURLException e){
                e.printStackTrace();
            }catch(XmlPullParserException e){
                e.printStackTrace();
            }catch(IOException e){
                e.printStackTrace();
            }

            return articlesTemp; // Body hidden for readibility
        }

        // Default case. Return empty list
        return new ArrayList<CropManagerArticle>();

    }

    public static boolean attemptNewsFeedParse(NewsFeed feed){
        // A standard RSS feed generated by Wordpress (Key: wp_rss)
        if(feed.feedType.equals(NewsFeed.WP_RSS)){

            int items = 0;
            int titles = 0;
            int pubdates = 0;
            int links = 0;

            try{

                URL url = new URL(feed.url);

                XmlPullParserFactory factory = XmlPullParserFactory.newInstance();
                factory.setNamespaceAware(false);
                XmlPullParser xpp = factory.newPullParser();

                xpp.setInput(getInputStream(url), "UTF_8");

                boolean insideItem = false;
                int eventType = xpp.getEventType();

                while(eventType != XmlPullParser.END_DOCUMENT){
                    if(eventType == XmlPullParser.START_TAG){
                        if(xpp.getName().equalsIgnoreCase("item")){
                            insideItem = true;
                            items++;
                        } else if(xpp.getName().equalsIgnoreCase("title")){
                            if(insideItem){
                                titles++;
                            }
                        } else if(xpp.getName().equalsIgnoreCase("pubdate")){
                            if(insideItem){
                                pubdates++;
                            }
                        } else if(xpp.getName().equalsIgnoreCase("link")){
                            if(insideItem){
                                links++;
                            }
                        }
                    } else if(eventType == XmlPullParser.END_TAG &&
                            xpp.getName().equalsIgnoreCase("item")){
                        insideItem = false;
                    }
                    eventType = xpp.next();
                }

                if(items > 0 && items == titles  && items == links){
                    return true;
                }

            }catch(MalformedURLException e){
                e.printStackTrace();
                return false;
            }catch(XmlPullParserException e){
                e.printStackTrace();
                return false;
            }catch(IOException e){
                e.printStackTrace();
                return false;
            }
        }
        return false;
    }

    // TWITTER FEEDS

    public static ArrayList<Tweet> parseTwitterFeed(TwitterFeed feed, Paging page){

        ArrayList<Tweet> tweets = new ArrayList<Tweet>();
        Twitter twitter = new TwitterFactory().getInstance();
        ResponseList<Status> statuses;

        // Parse differently depending on if this is a list of users or a single user's tweets
        if(feed.feedType.equals(TwitterFeed.USER)){

            try{
                statuses = twitter.getUserTimeline(feed.user, page);
            }catch(Exception e){
                e.printStackTrace();
                statuses = null;
            }

        }else{

            try{
                Log.d(feed.user, feed.listName);
                statuses = twitter.getUserListStatuses(feed.user, feed.listName, page);
            }catch(Exception e){
                e.printStackTrace();
                statuses = null;
            }

        }

        // This is where we convert the Status objects into Tweet objects
        if(statuses != null){

            for(Status status : statuses){

                Tweet tweet = new Tweet(status.getUser().getScreenName(),
                                        status.getUser().getName(),
                                        status.getText(),
                                        ((Long)status.getId()).toString(),
                                        status.getUser().getBiggerProfileImageURL(),
                                        status.getCreatedAt());
                tweets.add(tweet);

            }

        }

        return tweets;

    }

    // Get an input stream from a given URL
    public static InputStream getInputStream(URL url) {
        try{
            return url.openConnection().getInputStream();
        }catch(IOException e){
            return null;
        }
    }

    // YOUTUBE CHANNELS

    public static void testYoutubeChannel(String channel){
        new TestYoutubeChannelTask().execute(channel);
    }

    // Test a given Youtube channel to make sure it exists and whatnot
    public static class TestYoutubeChannelTask extends AsyncTask<String, Void, Boolean>{

        XmlPullParser xpp;
        URL url;
        boolean caughtException = false;
        String channel;

        @Override
        protected void onPreExecute(){ /* Nothing to do */ }

        @Override
        protected Boolean doInBackground(String... urls){
            try{
                channel = urls[0];
                return attemptYoutubeChannelParse(channel);
            }catch(Exception e){
                return false;
            }
        }

        @Override
        protected void onPostExecute(Boolean b){
            if(b){
                db.insertYoutubeChannel(channel);
                AddYoutubeChannel.list.setAdapter(new YoutubeChannelAdapter(context, R.layout.listitem_youtubechannel, db.getYoutubeChannels()));
                Toast toast = Toast.makeText(context, "Channel added", Toast.LENGTH_SHORT);
                toast.show();
            }else{
                Toast toast = Toast.makeText(context, "Channel does not exist", Toast.LENGTH_SHORT);
                toast.show();
            }
        }

    }

    public static boolean attemptYoutubeChannelParse(String channel){

        try{
            URL url = new URL("http://gdata.youtube.com/feeds/api/users/" + channel + "/uploads");

            XmlPullParserFactory factory = XmlPullParserFactory.newInstance();
            factory.setNamespaceAware(false);
            XmlPullParser xpp = factory.newPullParser();

            xpp.setInput(getInputStream(url), "UTF_8");
            int eventType = xpp.getEventType();

            while(eventType != XmlPullParser.END_DOCUMENT){
                if(eventType == XmlPullParser.START_TAG){
                    if(xpp.getName().equalsIgnoreCase("id")){
                        if(xpp.nextText().equals(url.toString()))
                            return true;
                    }
                }
                eventType = xpp.next();
            }
        }catch(Exception e){
            return false;
        }

        return false;

    }

    public static void getYoutubeVideos(String user){
        new GetYoutubeVideosTask().execute(user);
    }

    /*
    Returns a list of YoutubePlaylist's associated with the user passed as a parameter
     */
    public static class GetYoutubeVideosTask extends AsyncTask<String, Void, ArrayList<Playlist>>{

        @Override
        protected void onPreExecute(){
            Videos.list.setAdapter(new YoutubeAdapter(context, R.layout.listitem_videoitem, new ArrayList<YoutubeVideo>()));
        }

        @Override
        protected ArrayList<Playlist> doInBackground(String... urls){
            try{
                ArrayList<Playlist> playlists = getPlaylistsFromUser(urls[0]);
                for(Playlist playlist : playlists){
                    playlist.videos = getVideosFromPlaylist(playlist);
                }
                return playlists;
            }catch(Exception e){
                return new ArrayList<Playlist>();
            }

        }

        @Override
        protected void onPostExecute(ArrayList<Playlist> playlists){
            Videos.playlists = playlists;
            Log.d("playlists", ((Integer)playlists.size()).toString());

            // LEFT OFF HERE. Need to take the list of playlists and turn it into a segmented list of videos by playlist.
            ArrayList<YoutubeVideo> videosTemp = new ArrayList<YoutubeVideo>();

            for(Playlist playlist : playlists){
                videosTemp.add(new YoutubeVideo(playlist.getTitle(), true));
                videosTemp.addAll(getVideosFromPlaylist(playlist));
            }

            Videos.videos = videosTemp;
            Videos.list.setAdapter(new YoutubeAdapter(context, R.layout.listitem_videoitem, videosTemp));
            Videos.list.onRefreshComplete();

        }

    }

    public static ArrayList<Playlist> getPlaylistsFromUser(String user){

        ArrayList<Playlist> playlistsTemp = new ArrayList<Playlist>();
        ArrayList<String> names = new ArrayList<String>();
        ArrayList<String> urls = new ArrayList<String>();

        try{

            URL url = new URL("https://gdata.youtube.com/feeds/api/users/" + user + "/playlists?v=2");

            XmlPullParserFactory factory = XmlPullParserFactory.newInstance();
            factory.setNamespaceAware(false);
            XmlPullParser xpp = factory.newPullParser();

            xpp.setInput(getInputStream(url), "UTF_8");

            boolean insideItem = false;
            int eventType = xpp.getEventType();

            while(eventType != XmlPullParser.END_DOCUMENT){
                if(eventType == XmlPullParser.START_TAG){
                    if(xpp.getName().equalsIgnoreCase("entry")){
                        insideItem = true;
                    } else if(xpp.getName().equalsIgnoreCase("title")){
                        if(insideItem)
                            names.add(xpp.nextText());
                    } else if(xpp.getName().equalsIgnoreCase("content")){
                        if(insideItem)
                            urls.add(xpp.getAttributeValue(1));
                    }

                } else if(eventType == XmlPullParser.END_TAG &&
                        xpp.getName().equalsIgnoreCase("entry")){
                    insideItem = false;
                }

                eventType = xpp.next();
            }

            int min = min(names.size(), urls.size());
            for(int i = 0; i < min; i++)
            {
                playlistsTemp.add(new Playlist(names.get(i), urls.get(i)));
            }


        }catch(MalformedURLException e){
            e.printStackTrace();
        }catch(XmlPullParserException e){
            e.printStackTrace();
        }catch(IOException e){
            e.printStackTrace();
        }

        return playlistsTemp;

    }

    public static ArrayList<YoutubeVideo> getVideosFromPlaylist(Playlist playlist){

        ArrayList<YoutubeVideo> videosTemp = new ArrayList<YoutubeVideo>();

        ArrayList<String> titles = new ArrayList<String>();
        ArrayList<String> playlists = new ArrayList<String>();
        ArrayList<String> urls = new ArrayList<String>();
        ArrayList<String> thumbnailUrls = new ArrayList<String>();

        try{
            URL url = new URL(playlist.getUrl());

            XmlPullParserFactory factory = XmlPullParserFactory.newInstance();
            factory.setNamespaceAware(false);
            XmlPullParser xpp = factory.newPullParser();

            xpp.setInput(getInputStream(url), "UTF_8");

            boolean insideItem = false;
            boolean foundThumbnail = false;
            int eventType = xpp.getEventType();

            while(eventType != XmlPullParser.END_DOCUMENT){
                if(eventType == XmlPullParser.START_TAG){
                    if(xpp.getName().equalsIgnoreCase("entry")){
                        insideItem = true;
                    } else if(xpp.getName().equalsIgnoreCase("title")){
                        if(insideItem)
                        {
                            titles.add(xpp.nextText());
                            playlists.add(playlist.getTitle());
                        }
                    } else if(xpp.getName().equalsIgnoreCase("link")){
                        if(insideItem)
                            if(xpp.getAttributeValue(null, "rel").equals("alternate"))
                                urls.add(xpp.getAttributeValue(null, "href"));
                    } else if(xpp.getName().equalsIgnoreCase("media:thumbnail"))
                        if(insideItem)
                            if(xpp.getAttributeValue(null, "height").equals("90"))
                                if(!foundThumbnail){
                                    foundThumbnail = true;
                                    thumbnailUrls.add(xpp.getAttributeValue(null, "url"));
                                }

                } else if(eventType == XmlPullParser.END_TAG &&
                        xpp.getName().equalsIgnoreCase("entry")){
                    insideItem = false;
                    foundThumbnail = false;
                }

                eventType = xpp.next();
            }

            int min = min(titles.size(), playlists.size(), thumbnailUrls.size());
            for(int i = 0; i < min; i++)
            {
                videosTemp.add(new YoutubeVideo(titles.get(i), playlists.get(i), urls.get(i), thumbnailUrls.get(i)));
            }


        }catch(MalformedURLException e){
            e.printStackTrace();
        }catch(XmlPullParserException e){
            e.printStackTrace();
        }catch(IOException e){
            e.printStackTrace();
        }

        return videosTemp;

    }

    // HELPERS

    // Return the minimum value in a set of three numbers
    private static int min(int a, int b, int c) {

        if (b < a) {
            a = b;
        }
        if (c < a) {
            a = c;
        }
        return a;

    }

    // Return the minimum value in a set of two numbers
    private static int min(int a, int b) {

        if(a < b)
            return a;
        else
            return b;

    }

    private static String parseDate(String date) {
        try{
            return date.substring(0, date.indexOf("+") - 1);
        }catch(Exception e){
            return "Thu, 1 Jan 2013 00:00:00";
        }
    }

}
